


<script src="https://unpkg.com/@coinbase/wallet-sdk@3.6.2/dist/index.js"></script>





<!-- SCRIPTS TO ADD ON EVERY PAGE -->

<script src="https://unpkg.com/web3@latest/dist/web3.min.js"></script>
<!--<script type="text/javascript" src="https://unpkg.com/evm-chains/lib/index.js"></script>-->

<script type="text/javascript" src="https://cdn.ethers.io/scripts/ethers-v4.min.js" charset="utf-8"></script>
<script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
 <script src="
https://cdn.jsdelivr.net/npm/buffer@6.0.3/index.min.js
"></script>

<script type="text/javascript">
	var SCOPE = {}
</script>

<script type="text/javascript" src="https://uploads-ssl.webflow.com/64b98ae8b7e1288cf71ec395/64cae0bc9ff94cbabaf7cfb3_contractData.txt"></script>

<script type="module">
if (typeof window !== 'undefined') {
    if (!window.Buffer) {
      window.Buffer = Buffer
    }
    if (!window.global) {
      window.global = window
    }
    if (!window.process) {
      window.process = { env: {} }
    }
}
import {
    EthereumClient,
    w3mConnectors,
    w3mProvider,
    WagmiCore,
    WagmiCoreChains,
    WagmiCoreConnectors,
  } from "https://unpkg.com/@web3modal/ethereum@2.7.1";
  
  import { Web3Modal } from "https://unpkg.com/@web3modal/html@2.7.1";
    const { mainnet} = WagmiCoreChains;
  const { configureChains, createConfig,getAccount,readContract,writeContract,useAccount,
  useConnect,
  useDisconnect,
  useEnsAvatar,
  useEnsName,  } = WagmiCore;
  const chains = [mainnet];

let address;
  const projectId = "9f1004e719cc812fc74d8c310d3fe8a2";

  const { publicClient } = configureChains(chains, [w3mProvider({ projectId })]);
  const wagmiConfig = createConfig({
    autoConnect: true,
    connectors: [
      ...w3mConnectors({ chains, version: 2, projectId }),
      new WagmiCoreConnectors.CoinbaseWalletConnector({
        chains,
        options: {
          appName: "html wagmi example",
        },
      }),
    ],
    publicClient,
  });
  const ethereumClient = new EthereumClient(wagmiConfig, chains);
  export const web3Modal = new Web3Modal(
    {
      projectId,
      walletImages: {
        safe: "https://pbs.twimg.com/profile_images/1566773491764023297/IvmCdGnM_400x400.jpg",
      },
    },
    ethereumClient
  );
 let provider, selectedAccount;
 let accounts = [];

 
 if(address) {
   $("#address-textfield").val(address)
 }

 function setAddress(a) {
     console.log("address set")
     console.log(address)
     address = a
     saveAddress(a)
 
     SCOPE.address = a
 }
 
 function checkIfWasConnected(){
   if (getSavedAddress()) {
     onConnect()
   }
 }

 function getSavedAddress() {
    return window.localStorage != null ? window.localStorage.getItem("address") : null
 }
 
 function saveAddress(address) {
    if(!window.localStorage) {
        return;
    }
 
    if(!address || !address.startsWith("0x")) {
       return;
    }
 
    window.localStorage.setItem("address", address)
 }

 
 function showNavButtons(isConnected) {
   if (isConnected) {
     $("#btn-connect").hide()
     $("#connect-text").show()
     $("#btn-disconnect").show()
   } else {
     $("#btn-connect").show()
     $("#btn-disconnect").hide()
     $("#connect-text").hide()
   }
 }
 async function onConnect() {
 
   let instance


   provider = await web3Modal.openModal()
 
   SCOPE.provider = provider
    
 }
 async function onDisconnect(dontClear) {
 
   await web3Modal.openModal()
   if(!dontClear) {
     $("#address-textfield").val("")
   }
 
   setAddress(undefined)
 }
function checkstatus(){
 const account = getAccount()
 if(account.address !== undefined){
     showNavButtons(true)
     }
     else{
      showNavButtons(false)
     }
}
setInterval(checkstatus, 3000); 
 window.addEventListener('load', async () => {
 $("#btn-connect").on("click", () => {onConnect() });
   $("#btn-disconnect").on("click", ()=> {onDisconnect() });
  const account = getAccount()
console.log(account.address)
     if(account.address !== undefined){
     console.log('test')
     showNavButtons(true)
     }
     else{
      console.log('test1')
      showNavButtons(false)
     }
   
 });
 
 $("#address-form").submit(function(e) {
     e.preventDefault()
 
     const value = $("#address-textfield").val()
 
     if(value.length !== 42) {
         return false
     }
 
     onDisconnect(true)
 
     try {
         setAddress(value)
     }
     catch(e) {
           return false
     }
 
     return false
 })
 
 
 showNavButtons(false)
 
 checkIfWasConnected()
 
 //------------------------------------------------------------------------------------------------------------
 //----------     STATE MANAGER      -------------------------------------------
 //------------------------------------------------------------------------------------------------------------
 
 function updateState(state) {
     SCOPE.state = state
 }
 var currentState

var tokenBalance
var claimPercentVal
var claimTotalVal
var ethShareVal

var claimPercentText = document.getElementById('claim-percent')
var claimTotalText = document.getElementById('claim-total')
var ethShareText = document.getElementById('eth-share')


// Wallet variables

//Wallet connect stuff @credits DorekWas
const getSigner = () => {

}




/////// DATA FUNCTIONS /////// 
// Getting data for a specific wallet


async function claimDividends() {
  try{
  const data = await writeContract({
      address: SCOPE.mainTokenContract,
      abi: SCOPE.mainTokenContractABI,
      functionName: 'claim',
     
    })
}
catch(err)
{
console.log(error)
}
}


function updateData() {
  getTokenBalance()
  getClaimData()
}

async function getTokenBalance() {
   console.log(SCOPE.mainTokenContract);
  try{
 const account = getAccount()
 if(account.address !== undefined){
    const data = await readContract({
      address: SCOPE.mainTokenContract,
      abi: SCOPE.mainTokenContractABI,
      functionName: 'balanceOf',
      args: [account.address],
    })
    console.log(data)
    tokenBalance = parseFloat(ethers.utils.formatUnits(data.toString(),18))
    claimPercentText.innerHTML = ((tokenBalance / 1000000) * 100).toFixed(5) + "%"
}
}
catch(error)
{
console.log(error)
}
}
async function getClaimData() {
try{

				const web3 = new Web3('https://mainnet.infura.io/v3/19affef0dbd140e0aca95546e1c5bdd0')
        const provider = ethers.getDefaultProvider()
     const aimbotSigner = new ethers.Contract(SCOPE.mainTokenContract, SCOPE.mainTokenContractABI, provider)
         const account = getAccount()
         if(account.address !== undefined){
			 const data = await readContract({
      address: SCOPE.mainTokenContract,
      abi: SCOPE.mainTokenContractABI,
      functionName: 'stats',
      args: [account.address],
    })
   console.log(data)
  ethShareText.innerHTML = toFixed(convertToEther(data[0]))
 const asd =await web3.eth.getBalance("0x93314Ee69BF8F943504654f9a8ECed0071526439")
 console.log(asd);
claimTotalText.innerHTML = toFixed(convertToEther(asd))
}
}
catch(err)
{
console.log(err)
}
}

$("#claim-btn").on("click",() => {
	console.log("test")
	claimDividends()
})



setInterval(() => {
  checkState()
}, 1000)


function checkState() {
  if (typeof SCOPE.state != "undefined") {
      if (currentState == SCOPE.state) {
      } else {
        console.log("updating state")
        currentState = SCOPE.state
      }
  } else {
    currentState = "disconnected"
  }
  updateData()
}






//Wallet connect stuff

// small utilities to avoid having repeat code
function walletIsConnected() {
  if (typeof SCOPE.address !== 'undefined') {
    return true
  } else {
    return false
  }
}

function notConnectedAlert() {
  alert("Please connect wallet first")
}




function convertToNumber (bigNumber)
{
    return parseInt(bigNumber.toString())
}

function convertToEther (bigNumber)
{
    return parseFloat(ethers.utils.formatUnits(bigNumber.toString(), 18))
}

function convertToWei(ether)
{
    return ethers.utils.parseEther(ether.toString()).toString()
}

function convertToWeiHex (ether)
{
    return ethers.utils.parseEther(ether.toString()).toHexString()
}

function convertToHex (value)
{
    return ethers.BigNumber.from(value).toHexString()
}

function convertHexToAddress (hex)
{
    return "0x" + hex.substr(26, 40)
}

function convertBigNumberToHexAddress (number)
{
	let hex = number.toHexString()

	if(!hex)
	{
		return number
	}

	if(!hex.startsWith("0x"))
	{
		return number
	}

	hex = hex.substring(2)

	while(hex.length < 40)
	{
		hex = "0" + hex
	}

	return "0x" + hex
}

function sleep (ms) 
{
    return new Promise(resolve => setTimeout(resolve, ms))
}


function toFixed(x) {

  if(x > 0.1) {
    return x.toLocaleString('fullwide', {useGrouping:false})
  }

  x = x.toPrecision(4)

  if (Math.abs(x) < 1.0) {
    var e = parseInt(x.toString().split('e-')[1]);
    if (e) {
        x *= Math.pow(10,e-1);
        x = '0.' + (new Array(e)).join('0') + x.toString().substring(2);
    }
  } else {
    var e = parseInt(x.toString().split('+')[1]);
    if (e > 20) {
        e -= 20;
        x /= Math.pow(10,e);
        x += (new Array(e+1)).join('0');
    }
  }
  return x
}


function toNumber(number) {
  return parseInt(number.toString())
}
 </script>

